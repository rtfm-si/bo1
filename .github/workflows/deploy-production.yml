name: Deploy to Production

on:
  workflow_dispatch:  # Manual trigger ONLY
    inputs:
      confirm:
        description: 'Type "deploy-to-production" to confirm'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_API: ${{ github.repository }}/api
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  validate-confirmation:
    name: Validate Deployment Confirmation
    runs-on: ubuntu-latest
    steps:
      - name: Check confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy-to-production" ]; then
            echo "‚ùå Deployment confirmation failed!"
            echo "You must type 'deploy-to-production' to confirm."
            exit 1
          fi
          echo "‚úÖ Deployment confirmed"

  pre-deployment-checks:
    name: Pre-Deployment Checks
    needs: validate-confirmation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check staging health (optional)
        run: |
          echo "Checking staging environment health..."
          # TODO: Add monitoring check (Grafana API, Prometheus, etc.)
          # For now, just check if staging is responsive (non-blocking)
          if curl --fail --silent --max-time 5 https://staging.boardof.one/api/health 2>/dev/null; then
            echo "‚úÖ Staging is healthy"
          else
            echo "‚ö†Ô∏è  Staging is not available (skipping - not required for deployment)"
          fi

      - name: Verify all tests passed (optional)
        run: |
          echo "Verifying CI status..."
          # Check if CI tests passed on main (non-blocking)
          STATUS=$(gh api repos/${{ github.repository }}/commits/main/status --jq '.state' 2>/dev/null || echo "no-status")
          if [ "$STATUS" = "success" ]; then
            echo "‚úÖ All tests passed on main"
          elif [ "$STATUS" = "no-status" ]; then
            echo "‚ö†Ô∏è  No CI status found (skipping - not required)"
          else
            echo "‚ö†Ô∏è  CI status: $STATUS (continuing anyway)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for security alerts
        run: |
          echo "Checking for open security alerts..."
          # TODO: Add Dependabot/security alert check
          echo "‚ö†Ô∏è  Manual security review required"

  build-and-push:
    name: Build & Push Production Images
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_API }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-production:
    name: Deploy to Production (Safe Restart)
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment:
      name: production
      url: https://boardof.one

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify secrets are set
        run: |
          # Only verify SSH credentials (application secrets are in .env on server)
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "‚ùå PRODUCTION_HOST secret is not set!"
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "Add secret: PRODUCTION_HOST with value: 139.59.201.65"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_USER }}" ]; then
            echo "‚ùå PRODUCTION_USER secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            echo "‚ùå PRODUCTION_SSH_KEY secret is not set!"
            exit 1
          fi
          echo "‚úÖ SSH credentials configured"
          echo "Host: ${{ secrets.PRODUCTION_HOST }}"
          echo "User: ${{ secrets.PRODUCTION_USER }}"

      - name: Blue-Green Deployment to Production
        uses: appleboy/ssh-action@v1.0.3
        env:
          GITHUB_SHA: ${{ github.sha }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME_API: ${{ env.IMAGE_NAME_API }}
          IMAGE_NAME_FRONTEND: ${{ env.IMAGE_NAME_FRONTEND }}
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || '22' }}
          envs: GITHUB_SHA,REGISTRY,IMAGE_NAME_API,IMAGE_NAME_FRONTEND
          script: |
            set -e

            # Navigate to deployment directory
            cd /opt/boardofone

            # Pull latest configuration (stash any local changes first)
            git stash --include-untracked || true
            git pull origin main

            # Verify .env exists (fail fast if missing)
            if [ ! -f ".env" ]; then
              echo "‚ùå Error: .env file not found at /opt/boardofone/.env"
              exit 1
            fi
            echo "‚úÖ .env file exists"

            # Create override file (nginx runs on host, not in Docker)
            cat > docker-compose.prod.override.yml <<'OVERRIDE_EOF'
            version: '3.8'
            services: {}
            OVERRIDE_EOF
            echo "‚úÖ Override file created"

            # Detect current environment (blue or green, or neither for first deploy)
            CURRENT_ENV="none"
            if docker ps --format '{{.Names}}' | grep -q "^boardofone-api-1\$"; then
              CURRENT_ENV="blue"
            elif docker ps --format '{{.Names}}' | grep -q "^boardofone-green-api-1\$"; then
              CURRENT_ENV="green"
            elif docker ps --format '{{.Names}}' | grep -q "^bo1-api-prod\$"; then
              CURRENT_ENV="blue"  # Old naming
            fi

            echo "Current environment: ${CURRENT_ENV}"

            # Determine target environment (opposite of current)
            if [ "$CURRENT_ENV" = "blue" ] || [ "$CURRENT_ENV" = "none" ]; then
              TARGET_ENV="green"
              TARGET_PROJECT="boardofone-green"
              TARGET_API="boardofone-green-api-1"
            else
              TARGET_ENV="blue"
              TARGET_PROJECT="boardofone"
              TARGET_API="boardofone-api-1"
            fi

            echo "üöÄ Deploying to ${TARGET_ENV} environment..."

            # Build images for target environment
            echo "Building ${TARGET_ENV} images..."
            docker-compose -f docker-compose.prod.yml -f docker-compose.prod.override.yml -p ${TARGET_PROJECT} build --no-cache

            # Start target environment
            echo "Starting ${TARGET_ENV} containers..."
            docker-compose -f docker-compose.prod.yml -f docker-compose.prod.override.yml -p ${TARGET_PROJECT} up -d

            # Wait for containers to start
            echo "Waiting for ${TARGET_ENV} services to start..."
            sleep 30

            # Health checks using curl from HOST (not from inside container)
            echo "Running health checks on ${TARGET_ENV}..."

            for i in {1..10}; do
              if curl --fail --silent --max-time 5 http://localhost:8000/api/health > /dev/null 2>&1; then
                echo "‚úÖ ${TARGET_ENV} API is healthy"
                break
              fi
              echo "Waiting for ${TARGET_ENV} API... ($i/10)"
              sleep 3
              if [ $i -eq 10 ]; then
                echo "‚ùå ${TARGET_ENV} API health check failed"
                docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} logs --tail=50 api
                echo "üî¥ Deployment failed - stopping ${TARGET_ENV} containers"
                docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} down
                exit 1
              fi
            done

            # Additional health checks
            echo "Checking ${TARGET_ENV} database connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:8000/api/health/db > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} database health check failed"
              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} logs --tail=50 api
              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} down
              exit 1
            fi

            echo "Checking ${TARGET_ENV} Redis connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:8000/api/health/redis > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} Redis health check failed"
              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} logs --tail=50 api
              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} down
              exit 1
            fi

            # Run database migrations on target environment
            echo "Running database migrations on ${TARGET_ENV}..."
            docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} exec -T api alembic upgrade head

            # Switch nginx to target environment
            echo "Switching nginx to ${TARGET_ENV} environment..."
            sudo cp nginx/nginx-${TARGET_ENV}.conf /etc/nginx/sites-enabled/boardofone.conf

            # Test nginx configuration
            if ! sudo nginx -t; then
              echo "‚ùå Nginx configuration test failed"
              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} down
              exit 1
            fi

            # Reload nginx (zero-downtime traffic cutover!)
            sudo systemctl reload nginx
            echo "‚úÖ Traffic switched to ${TARGET_ENV}"

            # Monitor for errors (brief period)
            echo "Monitoring ${TARGET_ENV} for errors..."
            sleep 30

            ERROR_COUNT=$(docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} logs --tail=50 | grep -i "error\|exception\|failed" | grep -v "health" | wc -l || echo "0")
            if [ $ERROR_COUNT -gt 10 ]; then
              echo "‚ö†Ô∏è Warning: High error rate detected in ${TARGET_ENV} ($ERROR_COUNT errors)"
              echo "Rolling back to ${CURRENT_ENV}..."

              # Rollback: switch nginx back
              if [ "$CURRENT_ENV" != "none" ]; then
                sudo cp nginx/nginx-${CURRENT_ENV}.conf /etc/nginx/sites-enabled/boardofone.conf
                sudo nginx -t && sudo systemctl reload nginx
                echo "‚úÖ Rolled back to ${CURRENT_ENV}"
              fi

              docker-compose -f docker-compose.prod.yml -p ${TARGET_PROJECT} down
              exit 1
            fi

            # Stop old environment (if exists)
            if [ "$CURRENT_ENV" != "none" ]; then
              echo "Stopping old ${CURRENT_ENV} environment..."
              if [ "$CURRENT_ENV" = "blue" ]; then
                docker-compose -f docker-compose.prod.yml -f docker-compose.prod.override.yml down || true
              else
                docker-compose -f docker-compose.prod.yml -p boardofone-green down || true
              fi
              echo "‚úÖ Old ${CURRENT_ENV} environment stopped"
            fi

            echo "‚úÖ Deployment successful: ${GITHUB_SHA}"
            echo "üü¢ ${TARGET_ENV} environment is now serving traffic"

            # Cleanup old images
            docker system prune -f --filter "until=72h"

      - name: Post-deployment validation
        run: |
          echo "Running post-deployment validation..."
          sleep 10

          # Test production endpoints
          curl --fail https://boardof.one/api/health || exit 1
          curl --fail https://boardof.one/api/health/db || exit 1
          curl --fail https://boardof.one/api/health/redis || exit 1

          echo "‚úÖ Post-deployment validation passed"

  create-release:
    name: Create GitHub Release
    needs: deploy-to-production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version tag
        id: version
        run: |
          # Get current date for beta versioning
          VERSION="v1.0.0-beta.$(date +%Y%m%d.%H%M)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            CHANGES=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          echo "changes<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          body: |
            ## üöÄ Production Deployment

            **Deployed at**: ${{ github.event.head_commit.timestamp }}
            **Commit**: ${{ github.sha }}
            **Deployed by**: ${{ github.actor }}

            ### Changes
            ${{ steps.changelog.outputs.changes }}

            ### Deployment Details
            - Environment: Production
            - URL: https://boardof.one
            - Method: Blue-Green Deployment

            ### Health Checks
            - ‚úÖ API Health
            - ‚úÖ Database Connection
            - ‚úÖ Redis Connection
            - ‚úÖ All integration tests passed
          draft: false
          prerelease: true  # Mark as pre-release for beta

  notify:
    name: Notify Team
    needs: [deploy-to-production, create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Notify via ntfy.sh
        run: |
          if [ "${{ secrets.NTFY_TOPIC }}" != "" ]; then
            STATUS="${{ needs.deploy-to-production.result }}"
            if [ "$STATUS" == "success" ]; then
              curl -H "Title: üéâ Production Deployment Successful" \
                   -H "Priority: high" \
                   -H "Tags: rocket,success" \
                   -d "Commit: ${{ github.sha }} deployed to production by ${{ github.actor }}" \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            else
              curl -H "Title: ‚ùå Production Deployment Failed" \
                   -H "Priority: urgent" \
                   -H "Tags: warning,failure" \
                   -d "Commit: ${{ github.sha }} failed to deploy. Check logs." \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            fi
          fi
