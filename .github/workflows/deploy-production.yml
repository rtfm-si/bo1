name: Deploy to Production

on:
  workflow_dispatch:  # Manual trigger ONLY
    inputs:
      confirm:
        description: 'Type "deploy-to-production" to confirm'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_API: ${{ github.repository }}/api
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  validate-confirmation:
    name: Validate Deployment Confirmation
    runs-on: ubuntu-latest
    steps:
      - name: Check confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy-to-production" ]; then
            echo "‚ùå Deployment confirmation failed!"
            echo "You must type 'deploy-to-production' to confirm."
            exit 1
          fi
          echo "‚úÖ Deployment confirmed"

  pre-deployment-checks:
    name: Pre-Deployment Checks
    needs: validate-confirmation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check staging health (optional)
        run: |
          echo "Checking staging environment health..."
          # TODO: Add monitoring check (Grafana API, Prometheus, etc.)
          # For now, just check if staging is responsive (non-blocking)
          if curl --fail --silent --max-time 5 https://staging.boardof.one/api/health 2>/dev/null; then
            echo "‚úÖ Staging is healthy"
          else
            echo "‚ö†Ô∏è  Staging is not available (skipping - not required for deployment)"
          fi

      - name: Verify all tests passed (optional)
        run: |
          echo "Verifying CI status..."
          # Check if CI tests passed on main (non-blocking)
          STATUS=$(gh api repos/${{ github.repository }}/commits/main/status --jq '.state' 2>/dev/null || echo "no-status")
          if [ "$STATUS" = "success" ]; then
            echo "‚úÖ All tests passed on main"
          elif [ "$STATUS" = "no-status" ]; then
            echo "‚ö†Ô∏è  No CI status found (skipping - not required)"
          else
            echo "‚ö†Ô∏è  CI status: $STATUS (continuing anyway)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for security alerts
        run: |
          echo "Checking for open security alerts..."
          # TODO: Add Dependabot/security alert check
          echo "‚ö†Ô∏è  Manual security review required"

  build-and-push:
    name: Build & Push Production Images
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_API }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-production:
    name: Deploy to Production (Safe Restart)
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment:
      name: production
      url: https://boardof.one

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify secrets are set
        run: |
          # Only verify SSH credentials (application secrets are in .env on server)
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "‚ùå PRODUCTION_HOST secret is not set!"
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "Add secret: PRODUCTION_HOST with value: 139.59.201.65"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_USER }}" ]; then
            echo "‚ùå PRODUCTION_USER secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            echo "‚ùå PRODUCTION_SSH_KEY secret is not set!"
            exit 1
          fi
          echo "‚úÖ SSH credentials configured"
          echo "Host: ${{ secrets.PRODUCTION_HOST }}"
          echo "User: ${{ secrets.PRODUCTION_USER }}"

      - name: Blue-Green Deployment to Production
        uses: appleboy/ssh-action@v1.0.3
        env:
          GITHUB_SHA: ${{ github.sha }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME_API: ${{ env.IMAGE_NAME_API }}
          IMAGE_NAME_FRONTEND: ${{ env.IMAGE_NAME_FRONTEND }}
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || '22' }}
          envs: GITHUB_SHA,REGISTRY,IMAGE_NAME_API,IMAGE_NAME_FRONTEND
          script: |
            set -e

            # Navigate to deployment directory
            cd /opt/boardofone

            # Pull latest configuration (stash any local changes first)
            git stash --include-untracked || true
            git pull origin main

            # Verify .env exists (fail fast if missing)
            if [ ! -f ".env" ]; then
              echo "‚ùå Error: .env file not found at /opt/boardofone/.env"
              exit 1
            fi
            echo "‚úÖ .env file exists"

            # =================================================================
            # STEP 1: Create external network if it doesn't exist
            # =================================================================
            echo "Checking for existing networks..."
            docker network ls

            if ! docker network inspect bo1-network > /dev/null 2>&1; then
              echo "Creating external Docker network: bo1-network"
              docker network create bo1-network
            else
              echo "‚úÖ External network bo1-network already exists"
            fi

            # Double-check network is ready
            docker network inspect bo1-network > /dev/null 2>&1 || {
              echo "‚ùå Network bo1-network not found"
              exit 1
            }

            echo "‚úÖ External network bo1-network ready"

            # =================================================================
            # STEP 2: Detect current environment (blue/green/none)
            # =================================================================
            CURRENT_ENV="none"
            TARGET_ENV="blue"

            if docker ps --format '{{.Names}}' | grep -q "^boardofone-api-1\$"; then
              CURRENT_ENV="blue"
              TARGET_ENV="green"
            elif docker ps --format '{{.Names}}' | grep -q "^boardofone-green-api-1\$"; then
              CURRENT_ENV="green"
              TARGET_ENV="blue"
            elif docker ps --format '{{.Names}}' | grep -q "^bo1-api-prod\$"; then
              CURRENT_ENV="blue"  # Old naming
              TARGET_ENV="green"
            fi

            echo "üìç Current environment: ${CURRENT_ENV}"
            echo "üéØ Target environment: ${TARGET_ENV}"

            # =================================================================
            # STEP 3: Ensure shared infrastructure is running
            # =================================================================
            echo "üèóÔ∏è  Starting shared infrastructure..."

            # Start shared infrastructure using separate compose file
            docker-compose -f docker-compose.infrastructure.yml -p infrastructure up -d

            # Wait for shared services to be healthy
            echo "‚è≥ Waiting for shared infrastructure to be healthy..."
            sleep 10

            for i in {1..10}; do
              if docker exec infrastructure-postgres-1 pg_isready -U bo1 -d boardofone > /dev/null 2>&1; then
                echo "‚úÖ PostgreSQL is healthy"
                break
              fi
              echo "Waiting for PostgreSQL... ($i/10)"
              sleep 3
              if [ $i -eq 10 ]; then
                echo "‚ùå PostgreSQL health check failed"
                docker logs infrastructure-postgres-1 --tail=50
                exit 1
              fi
            done

            # Load REDIS_PASSWORD from .env
            export $(grep REDIS_PASSWORD .env | xargs)

            for i in {1..10}; do
              if docker exec infrastructure-redis-1 redis-cli -a "${REDIS_PASSWORD}" ping > /dev/null 2>&1; then
                echo "‚úÖ Redis is healthy"
                break
              fi
              echo "Waiting for Redis... ($i/10)"
              sleep 2
              if [ $i -eq 10 ]; then
                echo "‚ùå Redis health check failed"
                exit 1
              fi
            done

            echo "‚úÖ Shared infrastructure is running"

            # =================================================================
            # STEP 4: Deploy target environment
            # =================================================================
            echo "üöÄ Deploying ${TARGET_ENV} environment..."

            if [ "$TARGET_ENV" = "blue" ]; then
              # Deploy blue environment (default project, ports 8000/3000)
              TARGET_API_PORT=8000
              TARGET_FRONTEND_PORT=3000
              TARGET_PROJECT="boardofone"

              echo "Building blue environment images..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} build

              # Remove old containers (idempotent)
              docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} rm -f -s 2>/dev/null || true

              echo "Starting blue environment (api:${TARGET_API_PORT}, frontend:${TARGET_FRONTEND_PORT})..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} up -d
            else
              # Deploy green environment (green project, ports 8001/3001)
              TARGET_API_PORT=8001
              TARGET_FRONTEND_PORT=3001
              TARGET_PROJECT="boardofone-green"

              echo "Building green environment images..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} build

              # Stop and remove old green containers completely
              echo "Removing old green containers..."
              docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} down 2>/dev/null || true

              echo "Starting green environment (api:${TARGET_API_PORT}, frontend:${TARGET_FRONTEND_PORT})..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} up -d
            fi

            # =================================================================
            # STEP 5: Wait for target environment to be healthy
            # =================================================================
            echo "‚è≥ Waiting for ${TARGET_ENV} environment to start..."
            sleep 20

            echo "üè• Running health checks on ${TARGET_ENV} environment..."

            for i in {1..15}; do
              if curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health > /dev/null 2>&1; then
                echo "‚úÖ ${TARGET_ENV} API is healthy"
                break
              fi
              echo "Waiting for ${TARGET_ENV} API... ($i/15)"
              sleep 3
              if [ $i -eq 15 ]; then
                echo "‚ùå ${TARGET_ENV} API health check failed"
                docker-compose -p ${TARGET_PROJECT} -f docker-compose.prod.yml logs --tail=50 api
                echo "üî¥ Deployment failed - keeping current environment"
                exit 1
              fi
            done

            # Additional health checks
            echo "Checking ${TARGET_ENV} database connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health/db > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} database health check failed"
              docker-compose -p ${TARGET_PROJECT} -f docker-compose.prod.yml logs --tail=50 api
              exit 1
            fi

            echo "Checking ${TARGET_ENV} Redis connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health/redis > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} Redis health check failed"
              docker-compose -p ${TARGET_PROJECT} -f docker-compose.prod.yml logs --tail=50 api
              exit 1
            fi

            echo "‚úÖ All ${TARGET_ENV} health checks passed"

            # =================================================================
            # STEP 6: Run database migrations (on shared infrastructure)
            # =================================================================
            echo "üóÑÔ∏è  Running database migrations..."
            docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api alembic upgrade head

            # =================================================================
            # STEP 7: Switch nginx to target environment
            # =================================================================
            echo "üîÄ Switching nginx to ${TARGET_ENV} environment..."

            if [ "$TARGET_ENV" = "blue" ]; then
              sudo cp /opt/boardofone/nginx/nginx-blue.conf /etc/nginx/sites-available/boardofone
            else
              sudo cp /opt/boardofone/nginx/nginx-green.conf /etc/nginx/sites-available/boardofone
            fi

            # Test nginx configuration
            if ! sudo nginx -t; then
              echo "‚ùå nginx configuration test failed"
              exit 1
            fi

            # Reload nginx (zero downtime)
            sudo systemctl reload nginx
            echo "‚úÖ nginx reloaded with ${TARGET_ENV} configuration"

            # =================================================================
            # STEP 8: Stop old environment (if not first deploy)
            # =================================================================
            if [ "$CURRENT_ENV" != "none" ]; then
              echo "üõë Stopping ${CURRENT_ENV} environment..."

              # Wait a bit for in-flight requests to complete
              sleep 5

              if [ "$CURRENT_ENV" = "blue" ]; then
                docker-compose -f docker-compose.app.yml -p boardofone stop
              else
                docker-compose -f docker-compose.app.yml -p boardofone-green stop
              fi

              echo "‚úÖ ${CURRENT_ENV} environment stopped"
            fi

            # =================================================================
            # STEP 9: Cleanup
            # =================================================================
            echo "üßπ Cleaning up old Docker images..."
            docker system prune -f --filter "until=72h"

            echo ""
            echo "‚úÖ ‚úÖ ‚úÖ Deployment successful! ‚úÖ ‚úÖ ‚úÖ"
            echo ""
            echo "üìä Deployment Summary:"
            echo "   Current environment: ${CURRENT_ENV} ‚Üí ${TARGET_ENV}"
            echo "   Commit: ${GITHUB_SHA}"
            echo "   API Port: ${TARGET_API_PORT}"
            echo "   Frontend Port: ${TARGET_FRONTEND_PORT}"
            echo ""
            echo "üåê Production URL: https://boardof.one"
            echo ""

      - name: Post-deployment validation
        run: |
          echo "Running post-deployment validation..."
          sleep 10

          # Test production endpoints
          curl --fail https://boardof.one/api/health || exit 1
          curl --fail https://boardof.one/api/health/db || exit 1
          curl --fail https://boardof.one/api/health/redis || exit 1

          echo "‚úÖ Post-deployment validation passed"

  create-release:
    name: Create GitHub Release
    needs: deploy-to-production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version tag
        id: version
        run: |
          # Get current date for beta versioning
          VERSION="v1.0.0-beta.$(date +%Y%m%d.%H%M)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            CHANGES=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          echo "changes<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          body: |
            ## üöÄ Production Deployment

            **Deployed at**: ${{ github.event.head_commit.timestamp }}
            **Commit**: ${{ github.sha }}
            **Deployed by**: ${{ github.actor }}

            ### Changes
            ${{ steps.changelog.outputs.changes }}

            ### Deployment Details
            - Environment: Production
            - URL: https://boardof.one
            - Method: Blue-Green Deployment

            ### Health Checks
            - ‚úÖ API Health
            - ‚úÖ Database Connection
            - ‚úÖ Redis Connection
            - ‚úÖ All integration tests passed
          draft: false
          prerelease: true  # Mark as pre-release for beta

  notify:
    name: Notify Team
    needs: [deploy-to-production, create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Notify via ntfy.sh
        run: |
          if [ "${{ secrets.NTFY_TOPIC }}" != "" ]; then
            STATUS="${{ needs.deploy-to-production.result }}"
            if [ "$STATUS" == "success" ]; then
              curl -H "Title: üéâ Production Deployment Successful" \
                   -H "Priority: high" \
                   -H "Tags: rocket,success" \
                   -d "Commit: ${{ github.sha }} deployed to production by ${{ github.actor }}" \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            else
              curl -H "Title: ‚ùå Production Deployment Failed" \
                   -H "Priority: urgent" \
                   -H "Tags: warning,failure" \
                   -d "Commit: ${{ github.sha }} failed to deploy. Check logs." \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            fi
          fi
