name: Deploy to Production

on:
  workflow_dispatch:  # Manual trigger ONLY
    inputs:
      confirm:
        description: 'Type "deploy-to-production" to confirm'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_API: ${{ github.repository }}/api
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  validate-confirmation:
    name: Validate Deployment Confirmation
    runs-on: ubuntu-latest
    steps:
      - name: Check confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy-to-production" ]; then
            echo "‚ùå Deployment confirmation failed!"
            echo "You must type 'deploy-to-production' to confirm."
            exit 1
          fi
          echo "‚úÖ Deployment confirmed"

  security-scan:
    name: Security Scanning
    needs: validate-confirmation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install security tools
        run: |
          pip install bandit safety

      - name: Run Bandit security scan (Python code)
        run: |
          echo "üîç Running Bandit security scan..."
          # Generate JSON report for records
          bandit -r bo1/ backend/ -f json -o bandit-report.json || true

          # Run scan with fail threshold (medium/high severity)
          # -ll = only report issues with severity >= LOW and confidence >= LOW
          bandit -r bo1/ backend/ -ll -f screen
        continue-on-error: true  # Don't block deployment on warnings

      - name: Check dependency vulnerabilities (Safety)
        run: |
          echo "üîç Checking dependency vulnerabilities..."
          # Export dependencies
          pip freeze > requirements-check.txt

          # Run safety scan (new command - replaces deprecated 'check')
          # --output json for artifact
          safety scan --target requirements-check.txt --output json > safety-report.json || true

          # Run with default output for console
          safety scan --target requirements-check.txt
        continue-on-error: true  # Don't block deployment on warnings

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
          retention-days: 30

  pre-deployment-checks:
    name: Pre-Deployment Checks
    needs: [validate-confirmation, security-scan]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check staging health (optional)
        run: |
          echo "Checking staging environment health..."
          # TODO: Add monitoring check (Grafana API, Prometheus, etc.)
          # For now, just check if staging is responsive (non-blocking)
          if curl --fail --silent --max-time 5 https://staging.boardof.one/api/health 2>/dev/null; then
            echo "‚úÖ Staging is healthy"
          else
            echo "‚ö†Ô∏è  Staging is not available (skipping - not required for deployment)"
          fi

      - name: Verify all tests passed (optional)
        run: |
          echo "Verifying CI status..."
          # Check if CI tests passed on main (non-blocking)
          STATUS=$(gh api repos/${{ github.repository }}/commits/main/status --jq '.state' 2>/dev/null || echo "no-status")
          if [ "$STATUS" = "success" ]; then
            echo "‚úÖ All tests passed on main"
          elif [ "$STATUS" = "no-status" ]; then
            echo "‚ö†Ô∏è  No CI status found (skipping - not required)"
          else
            echo "‚ö†Ô∏è  CI status: $STATUS (continuing anyway)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for security alerts
        run: |
          echo "‚úÖ Security scanning completed (see security-scan job for details)"

  build-and-push:
    name: Build & Push Production Images
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_API }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./backend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          build-args: |
            BUILD_TIMESTAMP=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
          tags: |
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.prod
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-production:
    name: Deploy to Production (Safe Restart)
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment:
      name: production
      url: https://boardof.one

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify secrets are set
        run: |
          # Only verify SSH credentials (application secrets are in .env on server)
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            echo "‚ùå PRODUCTION_HOST secret is not set!"
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "Add secret: PRODUCTION_HOST with your server IP address"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_USER }}" ]; then
            echo "‚ùå PRODUCTION_USER secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            echo "‚ùå PRODUCTION_SSH_KEY secret is not set!"
            exit 1
          fi
          echo "‚úÖ SSH credentials configured"
          echo "Host: ${{ secrets.PRODUCTION_HOST }}"
          echo "User: ${{ secrets.PRODUCTION_USER }}"

      - name: Blue-Green Deployment to Production
        uses: appleboy/ssh-action@v1.0.3
        env:
          GITHUB_SHA: ${{ github.sha }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME_API: ${{ env.IMAGE_NAME_API }}
          IMAGE_NAME_FRONTEND: ${{ env.IMAGE_NAME_FRONTEND }}
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || '22' }}
          envs: GITHUB_SHA,REGISTRY,IMAGE_NAME_API,IMAGE_NAME_FRONTEND
          script: |
            set -e

            # Navigate to deployment directory
            cd /opt/boardofone

            # Pull latest configuration (stash any local changes first)
            git stash --include-untracked || true
            git pull origin main

            # Verify .env exists (fail fast if missing)
            if [ ! -f ".env" ]; then
              echo "‚ùå Error: .env file not found at /opt/boardofone/.env"
              exit 1
            fi
            echo "‚úÖ .env file exists"

            # =================================================================
            # STEP 1: Clean up old networks and prepare for deployment
            # =================================================================
            echo "Checking for existing networks..."
            docker network ls

            # Remove old project-specific networks if they exist (from previous deployments)
            docker network rm boardofone_bo1-network 2>/dev/null || true
            docker network rm boardofone-green_bo1-network 2>/dev/null || true

            # If bo1-network exists without proper labels, remove it
            if docker network inspect bo1-network > /dev/null 2>&1; then
              # Check if it has the compose project label
              NETWORK_LABEL=$(docker network inspect bo1-network --format '{{index .Labels "com.docker.compose.project"}}' 2>/dev/null || echo "")
              if [ -z "$NETWORK_LABEL" ] || [ "$NETWORK_LABEL" != "infrastructure" ]; then
                echo "Removing old bo1-network (incorrect labels)..."
                # Stop all containers using this network first
                docker network inspect bo1-network --format '{{range .Containers}}{{.Name}} {{end}}' | xargs -r docker stop 2>/dev/null || true
                docker network rm bo1-network 2>/dev/null || true
                echo "‚úÖ Old network removed"
              else
                echo "‚úÖ Network bo1-network has correct labels"
              fi
            fi

            echo "‚úÖ Network cleanup complete"

            # =================================================================
            # STEP 2: Detect current environment (blue/green/none)
            # =================================================================
            CURRENT_ENV="none"
            TARGET_ENV="blue"

            if docker ps --format '{{.Names}}' | grep -q "^boardofone-api-1\$"; then
              CURRENT_ENV="blue"
              TARGET_ENV="green"
            elif docker ps --format '{{.Names}}' | grep -q "^boardofone-green-api-1\$"; then
              CURRENT_ENV="green"
              TARGET_ENV="blue"
            elif docker ps --format '{{.Names}}' | grep -q "^bo1-api-prod\$"; then
              CURRENT_ENV="blue"  # Old naming
              TARGET_ENV="green"
            fi

            echo "üìç Current environment: ${CURRENT_ENV}"
            echo "üéØ Target environment: ${TARGET_ENV}"

            # =================================================================
            # STEP 3: Start shared infrastructure (creates bo1-network)
            # =================================================================
            echo "üèóÔ∏è  Starting shared infrastructure..."

            # Retry function for transient Docker errors (port allocation, networking)
            retry_docker_compose() {
              local max_attempts=5
              local wait_time=5
              local attempt=1
              local cmd="$@"

              while [ $attempt -le $max_attempts ]; do
                echo "Attempt $attempt/$max_attempts: Starting infrastructure..."

                if $cmd 2>&1 | tee /tmp/docker-compose-output.log; then
                  echo "‚úÖ Infrastructure started successfully"
                  return 0
                fi

                # Check if error is transient (port allocation, networking)
                if grep -q "port is already allocated\|failed programming external connectivity\|address already in use" /tmp/docker-compose-output.log; then
                  echo "‚ö†Ô∏è  Transient Docker error detected (port/network). Retrying in ${wait_time}s..."
                  sleep $wait_time
                  wait_time=$((wait_time * 2))  # Exponential backoff
                  attempt=$((attempt + 1))

                  # Try to clean up stale port bindings
                  docker network disconnect bo1-network infrastructure-ntfy-1 2>/dev/null || true
                  sleep 2
                else
                  # Non-transient error, fail immediately
                  echo "‚ùå Non-transient error occurred"
                  cat /tmp/docker-compose-output.log
                  return 1
                fi
              done

              echo "‚ùå Failed after $max_attempts attempts"
              cat /tmp/docker-compose-output.log
              return 1
            }

            # Start shared infrastructure using separate compose file
            # Use --no-recreate to prevent recreating existing containers (preserves data)
            retry_docker_compose docker-compose -f docker-compose.infrastructure.yml -p infrastructure up -d --no-recreate

            # Wait for shared services to be healthy
            echo "‚è≥ Waiting for shared infrastructure to be healthy..."
            sleep 10

            for i in {1..10}; do
              if docker exec infrastructure-postgres-1 pg_isready -U bo1 -d boardofone > /dev/null 2>&1; then
                echo "‚úÖ PostgreSQL is healthy"
                break
              fi
              echo "Waiting for PostgreSQL... ($i/10)"
              sleep 3
              if [ $i -eq 10 ]; then
                echo "‚ùå PostgreSQL health check failed"
                docker logs infrastructure-postgres-1 --tail=50
                exit 1
              fi
            done

            # Load REDIS_PASSWORD from .env
            export $(grep REDIS_PASSWORD .env | xargs)

            for i in {1..10}; do
              if docker exec infrastructure-redis-1 redis-cli -a "${REDIS_PASSWORD}" ping > /dev/null 2>&1; then
                echo "‚úÖ Redis is healthy"
                break
              fi
              echo "Waiting for Redis... ($i/10)"
              sleep 2
              if [ $i -eq 10 ]; then
                echo "‚ùå Redis health check failed"
                exit 1
              fi
            done

            echo "‚úÖ Shared infrastructure is running"

            # =================================================================
            # STEP 3b: Ensure ntfy is healthy (force restart if needed)
            # =================================================================
            echo "Checking ntfy health..."
            NTFY_HEALTHY=false
            for i in {1..3}; do
              if docker exec infrastructure-ntfy-1 wget -q --spider http://localhost:80/v1/health 2>/dev/null; then
                echo "‚úÖ ntfy is healthy"
                NTFY_HEALTHY=true
                break
              fi
              echo "ntfy not healthy, attempt $i/3..."
              sleep 2
            done

            if [ "$NTFY_HEALTHY" = false ]; then
              echo "‚ö†Ô∏è  ntfy is not healthy, forcing restart..."
              docker-compose -f docker-compose.infrastructure.yml -p infrastructure up -d --force-recreate ntfy
              sleep 5
              if docker exec infrastructure-ntfy-1 wget -q --spider http://localhost:80/v1/health 2>/dev/null; then
                echo "‚úÖ ntfy restarted and healthy"
              else
                echo "‚ö†Ô∏è  ntfy still unhealthy (non-blocking, continuing deployment)"
              fi
            fi

            # =================================================================
            # STEP 4: Deploy target environment
            # =================================================================
            echo "üöÄ Deploying ${TARGET_ENV} environment..."

            # Set build metadata for fresh builds
            BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            GIT_COMMIT_SHORT=$(echo "${GITHUB_SHA}" | cut -c1-7)

            if [ "$TARGET_ENV" = "blue" ]; then
              # Deploy blue environment (default project, ports 8000/3000)
              TARGET_API_PORT=8000
              TARGET_FRONTEND_PORT=3000
              TARGET_PROJECT="boardofone"

              echo "Building blue environment images with commit ${GIT_COMMIT_SHORT}..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} build \
                --build-arg BUILD_TIMESTAMP="${BUILD_TIMESTAMP}" \
                --build-arg GIT_COMMIT="${GIT_COMMIT_SHORT}"

              # Remove old containers (idempotent)
              docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} rm -f -s 2>/dev/null || true

              echo "Starting blue environment (api:${TARGET_API_PORT}, frontend:${TARGET_FRONTEND_PORT})..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} up -d --remove-orphans
            else
              # Deploy green environment (green project, ports 8001/3001)
              TARGET_API_PORT=8001
              TARGET_FRONTEND_PORT=3001
              TARGET_PROJECT="boardofone-green"

              echo "Building green environment images with commit ${GIT_COMMIT_SHORT}..."
              API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} build \
                --build-arg BUILD_TIMESTAMP="${BUILD_TIMESTAMP}" \
                --build-arg GIT_COMMIT="${GIT_COMMIT_SHORT}"

              # Stop and remove old green containers completely
              echo "Removing old green containers..."
              docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} down --remove-orphans 2>/dev/null || true

              # Wait for Docker to fully clean up containers (prevents "removal already in progress" race)
              echo "Waiting for container cleanup to complete..."
              sleep 5

              # Retry loop for starting green environment (handles Docker race conditions)
              for attempt in 1 2 3; do
                echo "Starting green environment (api:${TARGET_API_PORT}, frontend:${TARGET_FRONTEND_PORT})... attempt $attempt/3"
                if API_PORT=${TARGET_API_PORT} FRONTEND_PORT=${TARGET_FRONTEND_PORT} \
                  docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} up -d --remove-orphans 2>&1; then
                  echo "‚úÖ Green environment started successfully"
                  break
                fi

                if [ $attempt -lt 3 ]; then
                  echo "‚ö†Ô∏è Failed to start, waiting before retry..."
                  sleep 5
                else
                  echo "‚ùå Failed to start green environment after 3 attempts"
                  exit 1
                fi
              done
            fi

            # =================================================================
            # STEP 5: Wait for target environment to be healthy
            # =================================================================
            echo "‚è≥ Waiting for ${TARGET_ENV} environment to start..."
            sleep 20

            echo "üè• Running health checks on ${TARGET_ENV} environment..."

            for i in {1..15}; do
              if curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health > /dev/null 2>&1; then
                echo "‚úÖ ${TARGET_ENV} API is healthy"
                break
              fi
              echo "Waiting for ${TARGET_ENV} API... ($i/15)"
              sleep 3
              if [ $i -eq 15 ]; then
                echo "‚ùå ${TARGET_ENV} API health check failed"
                docker-compose -p ${TARGET_PROJECT} -f docker-compose.app.yml logs --tail=50 api
                echo "üî¥ Deployment failed - keeping current environment"
                exit 1
              fi
            done

            # Additional health checks
            echo "Checking ${TARGET_ENV} database connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health/db > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} database health check failed"
              docker-compose -p ${TARGET_PROJECT} -f docker-compose.app.yml logs --tail=50 api
              exit 1
            fi

            echo "Checking ${TARGET_ENV} Redis connectivity..."
            if ! curl --fail --silent --max-time 5 http://localhost:${TARGET_API_PORT}/api/health/redis > /dev/null 2>&1; then
              echo "‚ùå ${TARGET_ENV} Redis health check failed"
              docker-compose -p ${TARGET_PROJECT} -f docker-compose.app.yml logs --tail=50 api
              exit 1
            fi

            echo "‚úÖ All ${TARGET_ENV} health checks passed"

            # =================================================================
            # STEP 6: Extract static assets from frontend container
            # =================================================================
            echo "üì¶ Extracting static assets from frontend container..."

            # Create static asset directory for this environment
            STATIC_DIR="/var/www/boardofone/static-${TARGET_ENV}"
            sudo mkdir -p "$STATIC_DIR"

            # Copy static files from container to host filesystem
            docker cp "${TARGET_PROJECT}-frontend-1:/app/build/client/." "$STATIC_DIR/"

            # Set proper permissions
            sudo chown -R www-data:www-data "$STATIC_DIR"
            sudo chmod -R 755 "$STATIC_DIR"

            echo "‚úÖ Static assets extracted to $STATIC_DIR"

            # =================================================================
            # STEP 7: Run database migrations (on shared infrastructure)
            # =================================================================
            echo "üóÑÔ∏è  Running database migrations..."

            # Check current migration version
            echo "Checking current database migration version..."
            CURRENT_VERSION=$(docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run alembic current 2>/dev/null || echo "none")
            echo "Current migration version: $CURRENT_VERSION"

            # Check for pending migrations
            echo "Checking for pending migrations..."
            PENDING_MIGRATIONS=$(docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run alembic history --verbose 2>&1 | grep -c "-> head" || echo "0")
            echo "Pending migrations: $PENDING_MIGRATIONS"

            # Run migrations with error handling
            echo "Applying migrations..."
            if docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run alembic upgrade head 2>&1 | tee /tmp/migration.log; then
              echo "‚úÖ Migrations completed successfully"

              # Verify final migration version
              FINAL_VERSION=$(docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run alembic current 2>/dev/null || echo "none")
              echo "Final migration version: $FINAL_VERSION"
            else
              echo "‚ùå Migration failed! Rolling back deployment..."
              cat /tmp/migration.log
              docker-compose -p ${TARGET_PROJECT} -f docker-compose.app.yml logs --tail=100 api
              echo "üî¥ Deployment aborted - keeping current environment"
              exit 1
            fi

            # =================================================================
            # STEP 8: Switch nginx to target environment
            # =================================================================
            echo "üîÄ Switching nginx to ${TARGET_ENV} environment..."

            # Setup Let's Encrypt certificate if it doesn't exist
            if [ ! -f /etc/letsencrypt/live/boardof.one/fullchain.pem ]; then
              echo "üîí Setting up Let's Encrypt SSL certificate..."
              sudo bash /opt/boardofone/deployment-scripts/setup-letsencrypt.sh
              echo "‚úÖ Let's Encrypt certificate obtained"
            else
              echo "‚úÖ Let's Encrypt certificate already exists"
            fi

            # Remove any duplicate config files (boardofone.conf) that cause zone conflicts
            sudo rm -f /etc/nginx/sites-enabled/boardofone.conf
            sudo rm -f /etc/nginx/sites-available/boardofone.conf

            # Copy the correct environment config to sites-available
            if [ "$TARGET_ENV" = "blue" ]; then
              sudo cp /opt/boardofone/nginx/nginx-blue.conf /etc/nginx/sites-available/boardofone
            else
              sudo cp /opt/boardofone/nginx/nginx-green.conf /etc/nginx/sites-available/boardofone
            fi

            # Ensure symlink exists in sites-enabled
            sudo ln -sf /etc/nginx/sites-available/boardofone /etc/nginx/sites-enabled/boardofone

            # Test nginx configuration
            if ! sudo nginx -t; then
              echo "‚ùå nginx configuration test failed"
              sudo nginx -T 2>&1 | grep -A 5 "limit_req_zone" || true
              exit 1
            fi

            # Reload nginx (zero downtime)
            sudo systemctl reload nginx
            echo "‚úÖ nginx reloaded with ${TARGET_ENV} configuration"

            # =================================================================
            # STEP 9: Stop old environment (if not first deploy)
            # =================================================================
            if [ "$CURRENT_ENV" != "none" ]; then
              echo "üõë Stopping ${CURRENT_ENV} environment..."

              # Wait a bit for in-flight requests to complete
              sleep 5

              if [ "$CURRENT_ENV" = "blue" ]; then
                docker-compose -f docker-compose.app.yml -p boardofone stop
              else
                docker-compose -f docker-compose.app.yml -p boardofone-green stop
              fi

              echo "‚úÖ ${CURRENT_ENV} environment stopped"
            fi

            # =================================================================
            # STEP 10: Verify deployment and migrations
            # =================================================================
            echo "‚úÖ Verifying deployment..."

            # Verify migration version is up to date
            DEPLOYED_VERSION=$(docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run alembic current 2>/dev/null || echo "unknown")
            echo "Deployed migration version: $DEPLOYED_VERSION"

            # Verify critical tables exist
            echo "Verifying database schema..."
            TABLES_CHECK=$(docker-compose -f docker-compose.app.yml -p ${TARGET_PROJECT} exec -T api uv run python -c "
            from bo1.state.postgres_manager import db_session
            with db_session() as conn:
                with conn.cursor() as cur:
                    cur.execute(\"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'sessions', 'session_events', 'session_tasks', 'waitlist');\")
                    count = cur.fetchone()[0]
                    print(count)
            " 2>/dev/null || echo "0")

            if [ "$TABLES_CHECK" -ge 5 ]; then
              echo "‚úÖ All critical tables exist"
            else
              echo "‚ö†Ô∏è  Warning: Some critical tables may be missing (found: $TABLES_CHECK)"
            fi

            # =================================================================
            # STEP 11: Cleanup
            # =================================================================
            echo "üßπ Cleaning up old Docker images..."
            docker system prune -f --filter "until=72h"

            echo ""
            echo "‚úÖ ‚úÖ ‚úÖ Deployment successful! ‚úÖ ‚úÖ ‚úÖ"
            echo ""
            echo "üìä Deployment Summary:"
            echo "   Current environment: ${CURRENT_ENV} ‚Üí ${TARGET_ENV}"
            echo "   Commit: ${GITHUB_SHA}"
            echo "   API Port: ${TARGET_API_PORT}"
            echo "   Frontend Port: ${TARGET_FRONTEND_PORT}"
            echo "   Migration version: $DEPLOYED_VERSION"
            echo ""
            echo "üåê Production URL: https://boardof.one"
            echo ""

      - name: Post-deployment validation
        run: |
          echo "Running post-deployment validation..."
          sleep 10

          # Test backend API endpoints
          echo "üîç Testing backend API health..."
          curl --fail https://boardof.one/api/health || exit 1
          curl --fail https://boardof.one/api/health/db || exit 1
          curl --fail https://boardof.one/api/health/redis || exit 1
          curl --fail https://boardof.one/api/health/persistence || echo "‚ö†Ô∏è Persistence check skipped (no recent sessions)"

          # Test frontend health endpoint
          echo ""
          echo "üîç Testing frontend health..."
          curl --fail https://boardof.one/api/health || exit 1

          # Test that frontend pages are accessible (not 500 errors)
          echo ""
          echo "üîç Testing frontend page accessibility..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://boardof.one/)
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "   ‚úÖ Landing page accessible (HTTP $HTTP_STATUS)"
          else
            echo "   ‚ùå Landing page failed (HTTP $HTTP_STATUS)"
            exit 1
          fi

          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://boardof.one/login)
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "   ‚úÖ Login page accessible (HTTP $HTTP_STATUS)"
          else
            echo "   ‚ùå Login page failed (HTTP $HTTP_STATUS)"
            exit 1
          fi

          # Verify build metadata is present
          echo ""
          echo "üìã Build info from deployed API:"
          HEALTH_RESPONSE=$(curl -s https://boardof.one/api/health)
          echo "$HEALTH_RESPONSE" | jq -r '.details | "   build_timestamp: \(.build_timestamp)\n   git_commit: \(.git_commit)"' || echo "   (build info parsing failed - check response format)"

          echo ""
          echo "‚úÖ Post-deployment validation passed"

  create-release:
    name: Create GitHub Release
    needs: deploy-to-production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version tag
        id: version
        run: |
          # Get current date for beta versioning
          VERSION="v1.0.0-beta.$(date +%Y%m%d.%H%M)"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Generate changelog from commits since last release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            CHANGES=$(git log --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGES=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          fi

          echo "changes<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## üöÄ Production Deployment

            **Deployed at**: ${{ github.event.head_commit.timestamp }}
            **Commit**: ${{ github.sha }}
            **Deployed by**: ${{ github.actor }}

            ### Changes
            ${{ steps.changelog.outputs.changes }}

            ### Deployment Details
            - Environment: Production
            - URL: https://boardof.one
            - Method: Blue-Green Deployment

            ### Health Checks
            - ‚úÖ API Health
            - ‚úÖ Database Connection
            - ‚úÖ Redis Connection
            - ‚úÖ All integration tests passed
          draft: false
          prerelease: true  # Mark as pre-release for beta
          token: ${{ secrets.GITHUB_TOKEN }}

  notify:
    name: Notify Team
    needs: [deploy-to-production, create-release]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Notify via ntfy.sh
        run: |
          if [ "${{ secrets.NTFY_TOPIC }}" != "" ]; then
            STATUS="${{ needs.deploy-to-production.result }}"
            if [ "$STATUS" == "success" ]; then
              curl -H "Title: üéâ Production Deployment Successful" \
                   -H "Priority: high" \
                   -H "Tags: rocket,success" \
                   -d "Commit: ${{ github.sha }} deployed to production by ${{ github.actor }}" \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            else
              curl -H "Title: ‚ùå Production Deployment Failed" \
                   -H "Priority: urgent" \
                   -H "Tags: warning,failure" \
                   -d "Commit: ${{ github.sha }} failed to deploy. Check logs." \
                   https://ntfy.sh/${{ secrets.NTFY_TOPIC }}
            fi
          fi
