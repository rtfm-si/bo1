# Cost Optimisation Audit Manifest

<audit_manifest>
  <audit_type>cost_optimisation</audit_type>

  <purpose>
    Analyze LLM token usage, caching effectiveness, and compute efficiency. Identify opportunities to reduce operational costs without degrading deliberation quality.
  </purpose>

  <scope>
    - LLM call frequency and token consumption
    - Prompt length optimization opportunities
    - Research cache hit rates
    - Persona count vs. quality tradeoffs
    - Redundant computation detection
  </scope>

  <constraints>
    - Use existing cost_tracker data patterns
    - Do not modify prompts during audit
    - Respect deliberation quality requirements
    - Analysis only; no live cost changes
  </constraints>

  <required_inputs>
    - bo1/llm/cost_tracker.py
    - bo1/agents/research_metrics.py
    - bo1/prompts/*.py (token estimation)
    - backend/api/admin/research_cache.py
    - bo1/orchestration/persona_executor.py
  </required_inputs>

  <expected_outputs>
    - Token usage breakdown by operation type
    - Cache effectiveness metrics
    - Cost-per-session estimation
    - Top 5 cost reduction opportunities
    - Quality vs. cost tradeoff analysis
  </expected_outputs>

  <activation_conditions>
    - Monthly cost review
    - When LLM costs exceed budget
    - After adding new LLM-calling features
    - Before scaling user base
  </activation_conditions>

  <run_pattern>
    1. Analyze cost tracking implementation
    2. Estimate token usage per prompt type
    3. Review cache configuration and patterns
    4. Identify redundant LLM calls
    5. VERIFY existing implementations before generating tasks (see verification_checks)
    6. Output report to /audits/reports/cost_optimisation.report.md
  </run_pattern>

  <verification_checks>
    Before generating any task, verify it is NOT already implemented:

    - Prompt caching: Check for cache_control or prompt_caching in LLM calls
    - Context window: Check persona_executor.py for contribution history limits (already set?)
    - Aggregation caching: Check if Redis caching exists for get_session_costs() etc.
    - Token compression: Check if protocol boilerplate is already consolidated

    Skip generating tasks for items that already have implementations.
    If partial implementation exists, generate task for remaining work only.
  </verification_checks>
</audit_manifest>
