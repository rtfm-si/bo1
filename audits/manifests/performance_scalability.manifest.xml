# Performance Scalability Audit Manifest

<audit_manifest>
  <audit_type>performance_scalability</audit_type>

  <purpose>
    Identify performance bottlenecks and scalability constraints in the deliberation pipeline, database queries, and concurrent session handling.
  </purpose>

  <scope>
    - Database query patterns and index usage
    - LLM call parallelization and batching
    - Redis caching effectiveness
    - Concurrent session handling capacity
    - Memory and CPU hotspots in graph execution
  </scope>

  <constraints>
    - Focus on measurable metrics, not speculation
    - Load only relevant repository queries and async patterns
    - Respect GOVERNANCE performance thresholds
    - No load testing execution; analysis only
  </constraints>

  <required_inputs>
    - bo1/state/repositories/*.py
    - bo1/graph/execution.py
    - bo1/llm/cost_tracker.py
    - scripts/benchmark_indexes.py, scripts/explain_queries.py
    - Database schema from migrations/
  </required_inputs>

  <expected_outputs>
    - Query complexity analysis (N+1 detection, missing indexes)
    - Parallelization opportunities identified
    - Caching gap analysis
    - Scalability limits (sessions/sec estimate)
    - Priority-ranked optimization recommendations
  </expected_outputs>

  <activation_conditions>
    - Before production deployment
    - After significant database schema changes
    - When response times degrade
    - Monthly performance review
  </activation_conditions>

  <run_pattern>
    1. Review repository query patterns
    2. Check index coverage via benchmark scripts
    3. Analyze async/await patterns in execution
    4. Identify caching opportunities
    5. VERIFY existing implementations before generating tasks (see verification_checks)
    6. Output report to /audits/reports/performance_scalability.report.md
  </run_pattern>

  <verification_checks>
    Before generating any task, verify it is NOT already implemented:

    - Indexes: Check migrations/versions/ for existing index migrations (z15_*, a1b2c3d4e5f6_*, *_indexes.py)
    - pg_stat_statements: Check migrations/ for z16_enable_pg_stat_statements.py or similar
    - CTE rewrites: Grep for "WITH.*AS.*SELECT" in the target file to see if CTE already exists
    - Caching: Check if Redis cache calls exist in target repository methods
    - Query optimization: Run EXPLAIN on queries or check for existing optimization patterns

    Skip generating tasks for items that already have implementations.
    If partial implementation exists, generate task for remaining work only.
  </verification_checks>
</audit_manifest>
