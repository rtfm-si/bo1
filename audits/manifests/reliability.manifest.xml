# Reliability Audit Manifest

<audit_manifest>
  <audit_type>reliability</audit_type>

  <purpose>
    Evaluate system resilience, error recovery, retry logic, and graceful degradation capabilities. Ensure deliberation sessions survive transient failures.
  </purpose>

  <scope>
    - Exception handling patterns
    - Retry and backoff strategies
    - State recovery mechanisms
    - Database transaction management
    - External service failure handling (LLM, Redis)
  </scope>

  <constraints>
    - Focus on code patterns, not runtime testing
    - Respect GOVERNANCE reliability thresholds
    - Do not introduce new retry logic during audit
    - Analyze existing recovery paths only
  </constraints>

  <required_inputs>
    - bo1/graph/execution.py (error handling)
    - bo1/state/repositories/session_repository.py
    - bo1/services/replanning_service.py
    - backend/api/streaming.py (SSE reconnection)
    - Database session management in bo1/state/database.py
  </required_inputs>

  <expected_outputs>
    - Error handling coverage map
    - Retry strategy inventory
    - Single points of failure identification
    - State recovery capability assessment
    - Graceful degradation recommendations
  </expected_outputs>

  <activation_conditions>
    - Before production deployment
    - After reliability incidents
    - When adding external service dependencies
    - Quarterly resilience review
  </activation_conditions>

  <run_pattern>
    1. Map try/except patterns across critical paths
    2. Identify retry/backoff implementations
    3. Check state persistence and recovery
    4. Assess transaction boundaries
    5. Output report to /audits/reports/reliability.report.md
  </run_pattern>
</audit_manifest>
