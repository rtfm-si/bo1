# Reliability Audit Manifest

<audit_manifest>
  <audit_type>reliability</audit_type>

  <purpose>
    Evaluate system resilience, error recovery, retry logic, and graceful degradation capabilities. Ensure deliberation sessions survive transient failures.
  </purpose>

  <scope>
    - Exception handling patterns
    - Retry and backoff strategies
    - State recovery mechanisms
    - Database transaction management
    - External service failure handling (LLM, Redis)
  </scope>

  <constraints>
    - Focus on code patterns, not runtime testing
    - Respect GOVERNANCE reliability thresholds
    - Do not introduce new retry logic during audit
    - Analyze existing recovery paths only
  </constraints>

  <required_inputs>
    - bo1/graph/execution.py (error handling)
    - bo1/state/repositories/session_repository.py
    - bo1/services/replanning_service.py
    - backend/api/streaming.py (SSE reconnection)
    - Database session management in bo1/state/database.py
  </required_inputs>

  <expected_outputs>
    - Error handling coverage map
    - Retry strategy inventory
    - Single points of failure identification
    - State recovery capability assessment
    - Graceful degradation recommendations
  </expected_outputs>

  <activation_conditions>
    - Before production deployment
    - After reliability incidents
    - When adding external service dependencies
    - Quarterly resilience review
  </activation_conditions>

  <run_pattern>
    1. Map try/except patterns across critical paths
    2. Identify retry/backoff implementations
    3. Check state persistence and recovery
    4. Assess transaction boundaries
    5. VERIFY existing implementations before generating tasks (see verification_checks)
    6. Output report to /audits/reports/reliability.report.md
  </run_pattern>

  <verification_checks>
    Before generating any task, verify it is NOT already implemented:

    - Retry decorator: Check bo1/state/database.py for @retry_db or tenacity decorators
    - Circuit breaker: Grep for CircuitBreaker or circuit_breaker in target files
    - Deadlock handling: Check if 40P01 error code is handled in retry logic
    - SSE reconnection: Check backend/api/streaming.py for reconnection logic or Retry-After
    - Redis fallback: Check if PostgreSQL fallback exists for Redis operations
    - State recovery: Check checkpoint system for recovery mechanisms

    Skip generating tasks for items that already have implementations.
    If partial implementation exists, generate task for remaining work only.
  </verification_checks>
</audit_manifest>
